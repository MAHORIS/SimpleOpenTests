using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace SimpleOpenTests.UnitTesting
{
    public class ReflectionAssertException : UnitTestAssertException
    {
        public ReflectionAssertException()
            : base()
        {
        }
        public ReflectionAssertException(string message)
            : base(message)
        {
        }
        public ReflectionAssertException(string message, System.Exception innerException)
            : base(message, innerException)
        {
        }
        public ReflectionAssertException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
            : base(info, context)
        {
        }
    }

    public static class ReflectionAssert
    {
        private static string BaseAssertFailMsg { get; set; }

        static ReflectionAssert()
        {
            var className = string.Empty;
            var methodName = string.Empty;
            try
            {
                var mi = typeof(Assert).GetMethod("Fail", Type.EmptyTypes);
                className = mi.DeclaringType.Name;
                methodName = mi.Name;
                //mi.Invoke(null, null);
                Assert.Fail();
            }
            catch (Exception ex)
            {
                var assertionName = $"{className}.{methodName}";
                BaseAssertFailMsg = ex.Message.Replace(assertionName, "{0}"); ;
            }
        }

        private static TAssertException createException<TAssertException>(System.Reflection.MethodBase methodBase, string baseMessage, Exception innerException, string optionalMessage)
            where TAssertException : Exception
        {
            List<object> args = null;
            if ((methodBase != null) && (baseMessage != null))
            {
                args = new List<object>();
                var className = methodBase.DeclaringType.Name;
                var methodName = methodBase.Name;
                var assertionName = $"{className}.{methodName}";
                var failMessage = string.Format(baseMessage, assertionName) + optionalMessage ?? string.Empty;
                if (innerException != null)
                {
                    args.Add(innerException);
                    failMessage += innerException.Message;
                }
                args.Add(failMessage);
            }
            var exception = Activator.CreateInstance(typeof(TAssertException), args?.Reverse<object>().ToArray()) as TAssertException;
            return exception;
        }

        private static bool areSameType(Type type1, Type type2)
        {
            return type1.FullName.Equals(type2.FullName);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperty(object actual, string propertyName, string message)
        {
            var methodBase = System.Reflection.MethodBase.GetCurrentMethod();
            var failMsg = BaseAssertFailMsg;
            if (actual == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("actual"), message);
                throw exception;
            }
            if (propertyName == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyName"), message);
                throw exception;
            }
            if (string.IsNullOrWhiteSpace(propertyName))
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new ArgumentException().Message, "propertyName"), message);
                throw exception;
            }
            var propInfo = actual.GetType().GetProperty(propertyName);
            var hasProp = propInfo != null;
            if (!hasProp)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(string.Empty, propertyName), message);
                throw exception;
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperty(object actual, string propertyName)
        {
            ReflectionAssert.HasProperty(actual, propertyName, string.Empty);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperty(object actual, string propertyName, Type propertyType, string message)
        {
            // ***
            var methodBase = System.Reflection.MethodBase.GetCurrentMethod();
            var failMsg = BaseAssertFailMsg;
            if (actual == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("actual"), message);
                throw exception;
            }
            if (propertyName == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyName"), message);
                throw exception;
            }
            if (string.IsNullOrWhiteSpace(propertyName))
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new ArgumentException().Message, "propertyName"), message);
                throw exception;
            }
            var propInfo = actual.GetType().GetProperty(propertyName);
            var hasProp = propInfo != null;
            if (!hasProp)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(string.Empty, propertyName), message);
                throw exception;
            }
            // ***

            if (propertyType == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyType"), message);
                throw exception;
            }
            if (!areSameType(propertyType, propInfo.PropertyType))
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new InvalidCastException().Message, "propertyType"), message);
                throw exception;
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperty(object actual, string propertyName, Type propertyType)
        {
            ReflectionAssert.HasProperty(actual, propertyName, propertyType, string.Empty);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperties(object actual, IEnumerable<string> propertyNames, string message)
        {
            var methodBase = System.Reflection.MethodBase.GetCurrentMethod();
            var failMsg = BaseAssertFailMsg;
            if (actual == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("actual"), message);
                throw exception;
            }
            if (propertyNames == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyNames"), message);
                throw exception;
            }
            foreach (var propertyName in propertyNames)
            {
                if (propertyName == null)
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyNames"), message);
                    throw exception;
                }
                if (string.IsNullOrWhiteSpace(propertyName))
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new ArgumentException().Message, "propertyNames"), message);
                    throw exception;
                }
                var propInfo = actual.GetType().GetProperty(propertyName);
                var hasProp = propInfo != null;
                if (!hasProp)
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(string.Empty, propertyName), message);
                    throw exception;
                }
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperties(object actual, IEnumerable<string> propertyNames)
        {
            ReflectionAssert.HasProperties(actual, propertyNames, string.Empty);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperties(object actual, IEnumerable<string> propertyNames, IEnumerable<Type> propertyTypes, string message)
        {
            var methodBase = System.Reflection.MethodBase.GetCurrentMethod();
            var failMsg = BaseAssertFailMsg;
            if (actual == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("actual"), message);
                throw exception;
            }
            if (propertyNames == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyNames"), message);
                throw exception;
            }
            if (propertyTypes == null)
            {
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyTypes"), message);
                throw exception;
            }
            if (propertyNames.Count() != propertyTypes.Count())
            {
                var paramName = propertyNames.Count() > propertyTypes.Count() ? "propertyNames" : "propertyTypes";
                var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentOutOfRangeException(paramName), message);
                throw exception;
            }
            for (var index = 0; index < propertyNames.Count(); index++)
            {
                var propertyName = propertyNames.ElementAt(index);
                var propertyType = propertyTypes.ElementAt(index);
                if (propertyName == null)
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyNames"), message);
                    throw exception;
                }
                if (string.IsNullOrWhiteSpace(propertyName))
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new ArgumentException().Message, "propertyNames"), message);
                    throw exception;
                }
                var propInfo = actual.GetType().GetProperty(propertyName);
                var hasProp = propInfo != null;
                if (!hasProp)
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(string.Empty, propertyName), message);
                    throw exception;
                }
                if (propertyType == null)
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentNullException("propertyTypes"), message);
                    throw exception;
                }
                if (!areSameType(propertyType, propInfo.PropertyType))
                {
                    var exception = createException<ReflectionAssertException>(methodBase, failMsg, new ArgumentException(new InvalidCastException().Message, "propertyTypes"), message);
                    throw exception;
                }
            }
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public static void HasProperties(object actual, IEnumerable<string> propertyNames, IEnumerable<Type> propertyTypes)
        {
            ReflectionAssert.HasProperties(actual, propertyNames, propertyTypes, string.Empty);
        }
    }
}
